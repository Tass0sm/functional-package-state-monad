#+title: State Monad for Functional Packages
#+property: header-args:scheme :tangle ./implementation.scm

* Formalism

The goal is to manage some mutable state needed in building certain
packages. For instance, the racket package installation process requires this
(https://lists.gnu.org/archive/html/guix-devel/2020-11/msg00210.html). The
proposed solution is a state monad for functional packages. The mutable state is
passed as an input to every derivation, and each derivation produces a modified
copy of the state for the next step.

The normal state monad is defined as =s -> (a, s)=. In this case, every value is
a directory in the store (=Dir -> (Dir, Dir)=). We cannot handle store items in
the code directly, but we can handle the build tasks which produce them, so we
instead chain together these tasks. The build tasks are called derivations. This
modifies the type somewhat because a single derivation can produce two outputs,
which handles the =(Dir, Dir)= output. The new type is =Derivation ->
Derivation=. Creating derivations requires an open connection to the store, and
its cumbersome to pass this connection around. Instead, we lift this monad on
top of the store monad which Guix already provides. The new type is =m
Derivation -> m Derivation=. The mechanism for building up derivations through
g-expressions actually allows some more flexibility for the type of =s=. We can
instead make it a union of Derivations or Gexps in the store monad. However, to
do that we need to add a bit of information for its name, because Gexp's don't
carry that information and its useful to give a useful name to every derivation
that is created throughout the computation. So the final type for =s= is =Pair
(m Derivation | m Gexp) String=.

=return= takes some value and makes it into a member of our monad type (a state
parameterized monadic derivation). This input value is also of type =Pair (m
Derivation | m Gexp) String=.

=bind= composes a monadic-value with a function taking a non-monadic value and
producing a monadic-value. The non-monadic value does not depend on the state
input or the store connection, so its just a derivation. This is how one chains
together many packages which all can read the state, build the main output, and
then write out the modified state.

#+begin_src haskell
type Ungexpable = m Derivation | m Gexp
type State = Pair Ungexable String
type GuixState = State -> m Derivation

stateful_package_return :: State -> GuixState
stateful_package_bind :: GuixState -> (Derivation -> GuixState) -> GuixState

instance Monad GuixState where
  return = stateful_package_return
  bind = stateful_package_bind
#+end_src

* API
#+begin_src scheme
(use-modules (guix gexp)
             (guix store)
             (guix monads)
             (guix modules)
             (guix packages)
             (guix download)
             (guix derivations)
             (guix build-system trivial)
             (guix licenses)
             (gnu packages)
             (gnu packages base)

             (ice-9 match))
#+end_src

** COMMENT Functor Instance
*** =fmap=
** COMMENT Applicative Instance
*** =pure=
*** =application=
** Monad Instance
#+begin_src scheme
(define (stateful-package-return x)
  "My Return"
  (match-lambda ((mgexp-input . name)
     (mlet %store-monad ((x-drv x)
                         (gexp-input mgexp-input))
       (gexp->derivation
        (derivation-name x-drv)
        (with-imported-modules '((guix build utils))
          #~(begin
              (use-modules (guix build utils))

              (mkdir #$output)
              (copy-recursively #$x-drv #$output)

              (mkdir #$output:state)
              (copy-recursively #$gexp-input #$output:state))))))))
#+end_src

Bind conceptually takes one state parameterized derivation and a function from
some value (store item / derivation) to another state parameterized derivation, and it
produces a single state parameterized derivation.

#+begin_src scheme
;; m m derivation -> (derivation -> m m derivation) -> m m derivation
(define (stateful-package-bind mma fmmb)
  "My Bind"
  (match-lambda ((mgexp-input . name)
    (mlet* %store-monad ((a (mma (cons mgexp-input name)))
                         (act2 -> (fmmb a)))
      (act2 (cons (return (gexp (ungexp a "state"))) (derivation-name a)))))))
#+end_src

#+begin_src scheme
(define-monad %stateful-package-monad
  (bind stateful-package-bind)
  (return stateful-package-return))
#+end_src

** Utilities
*** =run-with-state=
*** =get=

#+begin_src scheme
(define (get)
  "My Get"
  (match-lambda ((mgexp-input . name)
                 (mlet %store-monad ((gexp-input mgexp-input))
                   (gexp->derivation
                    (string-append name "-get")
                    (with-imported-modules '((guix build utils))
                      #~(begin
                          (use-modules (guix build utils))

                          (mkdir #$output)
                          (copy-recursively #$gexp-input #$output)

                          (mkdir #$output:state)
                          (copy-recursively #$gexp-input #$output:state))))))))
#+end_src

*** =put=

#+begin_src scheme
(define (put x)
  "My Put"
  (match-lambda ((mgexp-input . name)
                 (mlet %store-monad ((x-drv x)
                                     (gexp-input mgexp-input))
                   (gexp->derivation
                    (string-append (derivation-name x-drv) "-put")
                    (with-imported-modules '((guix build utils))
                      #~(begin
                          (use-modules (guix build utils))

                          (mkdir #$output)

                          (mkdir #$output:state)
                          (copy-recursively #$x-drv #$output:state))))))))
#+end_src

*** COMMENT =sequence=
This really gives us all the derivations which we can use in our final
profile. Imagine having a list of monadic racket packages. One can put them in a
list and evaluate =(run-with-state (sequence list-of-pkgs) initial-state)= to
get a list of derivations that you can actually build and add to your profile.

* Example

#+begin_src scheme
(define initial-state
  (gexp->derivation "initial-state"
                    #~(begin
                        (mkdir #$output)
                        (call-with-output-file (string-append #$output "/state")
                          (lambda (p)
                            (display 0 p))))))

(define new-state
  (gexp->derivation "new-state"
                    #~(begin
                        (mkdir #$output)
                        (call-with-output-file (string-append #$output "/state")
                          (lambda (p)
                            (display 3 p))))))

(define act123
  (mbegin %stateful-package-monad
    (>>= (get)
         (lambda (x) (put new-state))
         (lambda (x) (stateful-package-return
                (gexp->derivation
                 "act3"
                 #~(begin
                     (mkdir #$output)
                     (call-with-output-file (string-append #$output "/out.txt")
                       (lambda (p)
                         (display "hello" p))))))))))

(define store (open-connection))

(run-with-store store (act123 (cons initial-state "initial-state")))
#+end_src
